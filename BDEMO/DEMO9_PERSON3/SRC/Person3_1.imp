IMPLEMENTATION

/*"
The implementation is built on the machines generated by BASE
generator; Person3Base.bse provides the specifications Person3Base and
Person3BaseCtx (a `context' machine) together with their implementations.
"*/

  Person3_1

REFINES

  Person3

SEES

/*"
We must ensure that the context machine provided by the BASE generator
is in scope.
"*/

  String_TYPE ,Bool_TYPE, Scalar_TYPE, Person3BaseCtx

IMPORTS

/*"
We import the generated machine.
"*/

  Person3Base(max_person,SEX)

PROPERTIES

/*"
We set our abstract object set equal to that provided in
{\em Person3BaseCtx\/}.
"*/

  PERSON = personbase_ABSOBJ

INVARIANT

/*"
Each of the abstract variables is equated to those provided in
{\em Person3Base\/}.
"*/

  person = personbase &
  person_name = name &
  person_age = age &
  person_sex = sex
  
OPERATIONS

/*"
{\bf Add\_person}\\
The operation provided for creating a new person, {\em make\_personbase\/},
takes a person's age and sex as input and returns a boolean value
indicating the success or otherwise of the operation (insufficient
memory may not have been allocated causing it to fail) together with a
token (which, if the operation is successful, points to the
newly-created person). Note that the name is not taken as a parameter:
mandatory strings, sequences and sets of a base are initialised to
empty when a new base record is created, and therefore if the create
operation is successful, we call the operation {\em mod\_name\/} with
the new token and the person's name as parameters; this operation may
also fail for the same reason as that given above, and in this case we
must be sure to kill the newly-created person. We return the new person
token together with the report.
"*/

  rep,new_person <-- Add_person(name_inp,age_inp,sex_inp) = 
    VAR rep_0,new_person_0 IN
      rep_0,new_person_0<--make_personbase(age_inp,sex_inp);
      IF (rep_0=TRUE) THEN
        rep_0<--mod_name(new_person_0,name_inp);
        IF (rep_0=FALSE) THEN
          kill_personbase(new_person_0)
        END
      END;
      rep:=rep_0;
      new_person:=new_person_0    
    END;

/*"
{\bf Print\_person\_details}\\
This operation takes a token as input; the token is first checked for
validity, and, if valid, the three fields are printed. 

If the token input to the operation is invalid, we return the report 
indicating that the operation failed.
"*/

 rep <-- Print_person_details(person_inp) = 
    VAR bb IN
      bb<--vld_personbase(person_inp);
      IF bb=TRUE THEN
        print_BaseObj_personbase(person_inp)
      END;
      rep:=bb
    END;

/*"
{\bf Remove\_person}\\
This is similar to the above operation; if the token is valid
we call the operation to remove a record {\em kill\_personbase\/}.
"*/

  Remove_person(person_inp) =
    VAR bb IN
      bb<--vld_personbase(person_inp);
      IF bb=TRUE THEN kill_personbase(person_inp) END
    END;

/*"
{\bf Save\_Person}\\
We use the {\em save\_Person3Base\/} operation provided to write the
entire database to file.
"*/

  Save_Person = VAR rr IN rr <-- save_Person3Base END;

/*"
{\bf  Restore\_Person}\\
We use the {\em restore\_Person3Base\/} operation provided to read the
entire database from file.
"*/

  Restore_Person = VAR rr IN rr <--  restore_Person3Base END

END

